##1、数据转集合
    Arrays.asList()，不能使用修改集合相关方法，它的add/remove/clear方法会抛出unsupportedOperationException()
    其实ArrayList并不是集合类的ArrayList，而是Arrays的内部类。而这个内部类没有这三个方法，所以会抛出异常。都是继承AbstractList。
    数组转集合正确的方法可以：new ArrayList<>(Arrays.asList("a","b","c"))

##2、集合删除元素应该使用迭代器来删除
        普通的for循环数删除其中某个元素时，后面的所有元素索引都会前移，此时for循环的指针却会下移，
    因此会略过下一个元素，解决方案是删除时将指针回调一次
        增强for动态删除时会报一个 java.util.ConcurrentModificationException的错误
    (不是删除每个元素都会抛异常，AbstractList中的modCount与ArrayList中的expectedModCount不相等)，
    而普通for却没有这个问题，但是每删除一个元素时，集合的size会发生变化，删除会有遗漏，
    所以建议使用迭代器Iterator对集合进行动态删除操作
    

##3、你说 HashMap 线程不安全，它为啥不安全呢？ 
    1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。
        通过jps和jstack命名查看死循环情况，通过该信息可明确知道死循环发生在HashMap的扩容函数中，
    根源在transfer函数中。
    2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。
        在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，
    因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全   
        if ((p = tab[i = (n - 1) & hash]) == null) // 如果没有hash碰撞则直接插入元素
            tab[i] = newNode(hash, key, value, null);

        注：如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。
        假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，
        此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给覆盖，发生线程不安全。


##4、二叉查找树，平衡二叉树、红黑树、B+树
###  O(logn) 已经可以表示所有底数的对数了
    N=2^x  ==> x=log2N
    二叉树：树中的每个节点最多只能有两个子节点，这样的树是二叉树。
    二叉查找树:一个节点的左子节点的关键字值小于这个父节点，右子节点的关键字值大于等于这个父节点。
    1）二叉查找树（排序树）
        二叉树时间复杂度在O(Log2n)到O(n)之间，当二叉树退化成了链表时时间复杂度就是O(n) 
    前序遍历（根左右）、中序遍历（左根右得到有序集合）、后续遍历（左右根）
    
    2）平衡二叉树（AVL树），时间复杂度：O(log2n)，数据增大n倍，时间增大log2n倍
        左右两个子树的高度差(平衡因子)的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，
    同时，平衡二叉树必定是二叉搜索树，反之则不一定
    
    3）红黑树(特殊的平衡二叉树) ，时间复杂度：O(log2n)
        一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。
     红黑树的特性:
    （1）每个节点或者是黑色，或者是红色。
    （2）根节点是黑色。
    （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
    （4）如果一个节点是红色的，则它的子节点必须是黑色的。
    （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。


##5、JVM调优，内存模型

##6、垃圾回收机制


## 7、hashCode 散列码/哈希码 的特性:
   时间复杂度 O(1)
   1.主要用于查找的快捷性，经常用于确定对象的存储地址
   2.如果两个对象相同，equal方法返回true，且hashCode相同
   3.两个对象的hashCode相同，并不一定表示两个对象相同，即equal不一定是true，只能说明两个对象在同一个散列存储结构中
   4.如果equals方法被重写，hashCode方法也尽量重写。
 HashSet HashTable HashMap 采用Hash算法存取对象
 调用对象的hashcode方法获得对象哈希码，然后根据哈希码找到相应的存储区域  hash(key) & (length-1)
 八大基本数据类型的hashcode等于数值本身，String的hashcode通过一个复杂的方式计算。
 
 
## 8、JVM
javap -c .class > a.txt   //JVM指令码手册
1、JVM内存结构
    线程共享：堆、方法区（java 8 元空间，物理内存）
    线程私有：虚拟机栈（栈贞：局部变量表、操作数栈、动态链接、方法出口）、本地方法栈、程序计数器（字节码指令地址）
      
2、jVM诊断工具调优
    堆分为：年轻代：老年代    1:2
    年轻代：占1/3， 包括Eden（伊甸园区）区、两个Survivor区（s1、s2） 8:1:1（将”gc root 【局部变量引用】“对象作为起点寻找存活对象）
        Eden区满了，会发生minor GC（包括Eden区和survivor区（s1或s2其中一个）），存活的对象的分代年龄会加1
        对象头是对象的组成部分包括GC分代年龄，当分代年龄达到15， 会将这样的对象移到老年代。
        如果有一批对象的大小超过survivor的50%，则这些对象就会直接放入老年代。
    老年代：占堆的2/3，老年代满了，触发full gc,会清理所有区域的垃圾对象，如果没有可清理内存溢出.OOM[OutOfMemory]

调优工具：jvisualvm
JVM调优的目的:减少full gc的次数
为什么要减少full gc ?
    stw:stop the world(停止世界)停掉用户线程，然后做垃圾收集。
阿里巴巴面试题：为什么full gc会停止用户线程？stw
    刚做完gc垃圾收集【堆内存和栈内存】，刚检查的非垃圾对象又变成垃圾对象了。（方法执行完，局部变量被垃圾回收）
    当在一段代码块定义一个变量时，Java在栈中为这个变量分配内存空间，当该变量退出其作用域后，
        Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

阿里巴巴面试题：能否对jvm调优，让其几乎不发生full gc？
    能，年轻代 2g，老年代 1g 让对象尽量放在年轻代就被干掉。 
电商网站大促导致频繁full gc？
Java虚拟机参数设置？



查看gc情况：
    1、首先，使用命令 jps -l 查看进程ID
    2、jstat 命令查看GC信息  jstat -gc 进程id 5s
    FGC：老年代垃圾回收次数
    FGCT：老年代垃圾回收消耗时间


## 9、Mysql索引数据结构与性能优化最佳实践
 1）索引是帮助Mysql高效获取数据的【排好序】的数据结构
    mysql索引为啥不用红黑树？（树的高度太高，减少磁盘I/O操作） h<=3
 2）B+树 （树的高度h<=3）根节点是常驻内存的
    节点左边的地址元素<  索引节点  <=节点右边的地址元素  
    1、非叶子节点不存储data，只存储索引（冗余），可以放更多的索引
    2、叶子节点包含所有索引字段
    3、叶子节点用指针连接，提高区间访问的性能（索引从左到右递增，方便范围查找）
    
 3）mysql存储引擎：
    MyISAM：.frm [表结构]、.MYD[表数据]、.MYI[表索引] 非聚集索引
        查找数据过程：根据索引字段到.MYI文件找到根节点位置，然后一直找到叶子节点中索引存储的磁盘文件地址（data），
        到.MYD文件中找到对应数据
    innodb：.frm[表结构]、.ibd[表索引和数据]  聚集索引
        1、表数据文件本身就是按B+tree组织的一个索引结构文件
        2、聚集索引-叶子节点包含了完成的数据记录
        3、为什么InnoDB表必须有主键（如果没有主键，mysql会自动找一个唯一性的字段为主键），
           并且推荐使用整型的自增主键？（占用磁盘空间少【对比uuid】，整型索引比较大小时效率高）
               扩展：因为如果是自增的，直接插在最后一个叶子节点指针的后面，
                    如果不是自增的，节点插在叶子节点的中间，如果叶子节点满了，可能导致节点分裂，再做平衡，效率低
        4、为什么非主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）
        
 4）索引方法：
    Hash（等值查询效率更高，O(1)）、B+Tree （范围查找、排序，O(logn)）      
    mysql-> data目录（对应数据库）-> 表名
 
 5）mysql为什么用B+树，不用B树？
    B树和B+树的区别：
        B+树在叶子节点上增加了双向指针
        非叶子节点的数据放到叶子节点中，非叶子节点放了一些冗余索引
    1、B+树适合区间范围查找
    2、每个节点的数据大小是16KB，如果非叶子节点存储了数据，
       肯定就存储不了那么多索引了，导致树的高度会增加，远远大于B+树的高度3
       
 6）联合索引的底层存储结构长什么样？不建议建多个单值索引
     索引最左前缀法则（a、b、c：根据建索引的顺序比较大小，只有根据第一个索引开始查找的才走索引） 
     为什么呢？因为B+树是以第一个索引大小开始排序的，如果不是以第一个索引开始查找，索引是无序的。    
       
 注：B+树的节点默认大小是16KB，索引大小是8Byte,索引地址是6Byte, 16KB/(8+6)b = 1170;
    差不多一个叶子节点可以放1170个索引。假设叶子节点一行数据大小和索引占用空间为1KB，则
    可以放16个索引和数据
    一共可以存储数据：1170*1170*16=2千多万
    聚集索引：表中存储的数据按照索引的顺序存储，检索效率高，但是对数据更新影响较大
    非聚集索引：表示数据和索引存储在不同地方，索引带有指针指向数据的磁盘存储位置，效率低，对数据更新影响较小
    
 7）mvcc多版本并发控制技术
    mysql会给每张表新增两个隐藏字段：事务ID（trx_id, 增删改才会生成，6Byte），回滚指针(7Byte)
    a、更新数据的时候，会新增一条数据，把之前的数据放入undolog中，回滚指针指向undolog中的记录。
    b、第一次查询的时候会生成一个快照:  [未提交事务id数组], 最大事务id
        session在执行第一次查询sql时会生成快照，它由执行查询时所有未提交事务id数组（数组里最小的为min_id）和已创建的最大事务id(max_id)
    组成，查询数据结果需要跟快照对比从而得到快照结果。
    版本链对比规则：
        1.如果trx_id < min_id 表示这个版本是已提交的事务生成的，这个数据是可见的。
        2.如果trx_id > max_id 表示这个版本是由将来启动的事务生成的，是肯定不可见的。
        3.如果 min_id <= trx_id <= max_id，包括两种情况：
            3.1 若row的trx_id 在数组中，表示这个版本是由未提交的事务生成，不可见。
            3.2 若row的trx_id 不在数组中，表示这个版本是已提交的事务生成的，可见的。
    在 MVCC 中，对于读操作可以分为两种读：
    快照读：读取的历史数据，简单的 select 语句，不加锁，MVCC 实现可重复读，使用的是 MVCC 机制读取 undo 中的已经提交的数据。
        所以它的读取是非阻塞的。
    当前读：需要加锁的语句，update，insert，delete，select...for update 等等都是当前读。
   
##10、Mysql 数据库事务以及锁原理
###0、mysql命令
    1.show variables like 'autocommit'; // 查看是否自动提交，默认自动提交
        begin;开启事务  commit;提交事务
    2.设置事务隔离级别
      set session trasaction isolation level REPEATABLE READ; // 可重复读
    
###1、事务特性：（ACID）
    1.原子性：事务要么全不做，要么全做
    2.隔离性：事务之间互不影响
    3.一致性：数据保持一致（转账：总数不变）
    4.持久性：转账记录永久保持
###2、事务并发问题
    1.脏读：一个事务读取到另一个事务未提交的更新数据。
    2.不可重复读：一个事务读取到另一个事务已提交的更新数据，在同一个事务中，多次读取同一数据返回的结果不同
    3.幻读：一个事务读到另一个事务已提交的 insert 数据。
###3、事务隔离级别：（事务本身是可以读取到未提交的数据）
    1.读未提交【一个事务可以读到其他事务还没有提交的数据】：会发生 脏读、不可重复读、幻读
    2.读已提交【一个事务只能读到另一个已经提交的事务修改过的数据，每一次select的时候都会生成一个快照】：会发生不可重复读、幻读，但不会发生脏读
    3.可重复读【一个事务第一次读过某条记录后，即使其他事务修改了该记录的值并提交了，该事务之后再读该条记录时，读到的仍是第一次读到的值，只有
       第一次select的时候会生成一个快照】
        （mysql默认事务隔离级别）：会发生幻读，不会发生脏读、不可重复读。
    4.串行化：都不会发生，
    注：这四种隔离级别是sql标准定义，不同的数据库会有不同的实现，特别要注意“mysql在可重复隔离级别下，是可以禁止幻读的发生的。gap锁”
###4、锁
   ####1.行锁
   1.读锁：共享锁，S锁；其他事务可以继续加共享锁，但是不能继续加排他锁。
   2.写锁：排它锁，X锁；一旦加了写锁之后，其他事务就不能加锁了。
   select：不加锁
   
   SELECT * FROM tb_user LOCK in SHARE MODE; //加读锁
   SELECT * FROM tb_user for update; //加写锁
   delete、update、insert 加写锁
   
   ####2.意向锁（表级锁），意向锁相互兼容
    意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存
   1.意向共享锁：IS锁
   2.意向排它锁：IX锁
   emp：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），
   这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。
   
   这个锁有什么用呢?为什么需要这个锁呢?首先说一下如果没有这个锁，要给这个表加上表锁，一般的做法是去遍历每一行看看它是否有行锁，这样的话效率太低。
   而我们有意向锁，只需要判断是否有意向锁即可（表明肯定有行锁），不需要再去一行行的去扫描。
   
   ####3.自增长锁（特殊的表锁机制，提升并发插入性能）
   
###5、InnoDB锁算法
    exp：https://www.cnblogs.com/paul8339/p/9936005.html
    查看锁算法：select * from information_schema.INNODB_LOCKS
    ####1.记录锁
        锁住的是索引记录，而不是我们真正的数据记录，如果加锁的列没有索引，则会进行全表记录加锁。
        如果锁的是非主键索引，会在自己的索引上面加锁之后然后再去主键上面加锁锁住。
        如果没有表上没有索引(包括没有主键)，则会使用隐藏的主键索引进行加锁。
    ####2.间隙锁
        锁间隙的意思就是锁定某一个范围，间隙锁又叫 gap 锁，其不会阻塞其他的 gap 锁，但是会阻塞插入间隙锁，这也是用来防止幻读的关键。
    ####3.next-key锁
        这个锁本质是记录锁 + gap 锁。在 RR 隔离级别下(InnoDB 默认)，InnoDB 对于行的扫描锁定都是使用此算法，
        但是如果查询扫描中有唯一索引会退化成只使用记录锁。
        这么做的理由是：非唯一索引加 next-key 锁由于不能确定明确的行数有可能其他事务在你查询的过程中，再次添加这个索引的数据，
        导致隔离性遭到破坏，也就是幻读。唯一索引由于明确了唯一的数据行，所以不需要添加间隙锁解决幻读。
    ####4.插入意向锁
        可以看出插入意向锁是在插入的时候产生的，在多个事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。
        假设有一个记录索引包含键值 4 和 7，不同的事务分别插入 5 和 6，每个事务都会产生一个加在 4-7 之间的插入意向锁，获取在插入行上的排它锁，
        但是不会被互相锁住，因为数据行并不冲突。这里要说明的是如果有间隙锁了，插入意向锁会被阻塞。
    备注：    
    如果用没有索引的数据，其会对所有聚集索引上都加上 next-key 锁。
    在快照读读情况下，mysql通过mvcc来避免幻读。
    在当前读读情况下，mysql通过next-key来避免幻读。
   
   
   
   
       IX      IS      X       S
IX    兼容    兼容    不兼容   不兼容
IS    兼容    兼容    不兼容   兼容
X     不兼容  不兼容  不兼容   不兼容
S     不兼容  兼容    不兼容   兼容
   
   
对比项   innoDB      MyIsam
事务     支持         不支持
锁    支持MVCC行锁     表锁
外键     支持         不支持

    
    
    
    
    



